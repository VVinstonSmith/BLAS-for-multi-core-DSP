
============================= 寄存器分配 =============================
标量寄存器分配：
R26: N+2
R59: 64
R61: 16*4*8
R7: 行索引i
R8: 列索引j
VR61: 0
VR62: 0.2
VR63: 1.0

地址偏移寄存器分配：
R25, OR1: (N+2) * 1/2
R26, OR2: (N+2)
R27, OR3: (N+2) * 3/2
R28, OR4: (N+2)*3
R29, OR5: N * 1/2
============================= src_A =============================
地址偏移量：
R55: (N+2)*8   (临时)
R56: (N+2)*2*8 (临时)
R57: (N+2)*4*8
-----------------------------------------------------------------
行首地址：
          R42
     R43       R44
          R45
初始化：
R42 = src_A + 8
R43 = src_A + (N+2)*8
R45 = R42 + (N+2)*2*8
R44 = R43 + 16
更新：
R42,R43,R44,R45 += (N+2)*4*8
-----------------------------------------------------------------
向量地址：
            AR0++[OR1]
AR1++[OR1]  AR0--[OR1]  AR2++[OR1]
AR1++[OR1]  AR3++[OR1]  AR2++[OR1]
AR1++[OR1]  AR3++[OR1]  AR2++[OR1]
AR1--[OR3]  AR3++[OR1]  AR2--[OR3]
            AR3--[OR3]
初始化：
SMVAGA      R42, AR0
SMVAGA      R43, AR1
SMVAGA      R44, AR2
SMVAGA      R45, AR3
更新：
AR0,AR1,AR2,AR3 += 16*4*8
-----------------------------------------------------------------
向量寄存器：
            VR(0~3)     
VR(4~7)     VR(8~1)     VR(12~15)
VR(16~19)   VR(20~23)   VR(24~27)
VR(28~31)   VR(32~35)   VR(36~39)
VR(40~43)   VR(44~47)   VR(48~51)
            VR(52~55)

============================= dst_B =============================
地址偏移量：
R51: N*2*8
R52: N*4*8
-----------------------------------------------------------------
行首地址：
        %1

        R46
初始化：
%1 = dst_B
R46 = dst_B + N*2*8
更新：
%1,R46 += N*4*8
-----------------------------------------------------------------
向量地址：
        AR5++[OR5]     
        AR5--[OR5]
        AR6++[OR5]
        AR6--[OR5]
初始化：
SMVAGA      %1, AR5
SMVAGA      R46, AR6
更新：
AR5,AR6 += 16*4*8
-----------------------------------------------------------------
向量寄存器：     
        VR(12~15)
        VR(24~27)
        VR(36~39)
        VR(48~51)
=================================================================





微内核变量初始化+循环逻辑：
=================================================================
;; %0:src_a (源数据首地址),    %1:dst_b (目的数据首地址),
;; %2:m (目的数据行数),    %3:n (目的数据列数),    %4:N (源数据buffer区行长度)

VMOVI			3FC999999999999A, VR62  ;; VR62 = 0.2
VMOVI			3FF0000000000000, VR63	;; VR63 = 1	
VMOVI			0x00, VR61  			;; VR61 = 0.0
SMOVI24         64, R59                 ;; R59 = 64
SMOVI24         512, R61                ;; R61 = 16*4*8
SADD.M1         2, %4, R26              ;; R26 = N+2

SSHFLL          3, R26, R55             ;; R55 = (N+2)*8	
SSHFLL          4, R26, R56             ;; R56 = (N+2)*2*8	
SSHFLL          5, R26, R57             ;; R57 = (N+2)*4*8	
SSHFLL          4, %4, R51              ;; R51 = N*2*8		
SSHFLL          5, %4, R52              ;; R52 = N*4*8		

SSHFLR          1, R26, R25             ;; R25 = (N+2)*1/2	
SADD.M1         R26, R25, R27           ;; R27 = (N+2)*3/2	
SSHFLL			1, R27, R28				;; R28 = (N+2)*3	
SSHFLR          1, %4, R29              ;; R29 = N * 1/2	

SMVAGA.M1       R26, OR2                ;; OR2 = (N+2)		
SMVAGA.M1       R25, OR1                ;; OR1 = (N+2)*1/2	
SMVAGA.M1       R27, OR3                ;; OR3 = (N+2)*3/2	
SMVAGA.M1       R28, OR4                ;; OR4 = (N+2)*3	
SMVAGA.M1       R29, OR5                ;; OR5 = N * 1/2	

;; 地址初始化：
SADD.M1         8, %0, R42              ;; R42 = src_A + 8
SADD.M1         R55, %0, R43            ;; R43 = src_A + (N+2)*8
SADD.M1         R56, R42, R45           ;; R45 = R42 + (N+2)*2*8
SADD.M1         16, R43, R44            ;; R44 = R43 + 16
SADD.M1         R51, %1, R46            ;; R46 = dst_B + N*2*8

SMVAGA.M1       R42, AR0  
SMVAGA.M1       R43, AR1
SMVAGA.M1       R44, AR2
SMVAGA.M1       R45, AR3
SMVAGA.M1       %1, AR5 
SMVAGA.M1       R46, AR6
SMOVI24         0, R1

;; 加载第一批数据 ...

SMOVI24         0, R7                   ;; i=0
loop_m:
    SADD    4, R7, R7                   ;; i += 4
    SLT     R7, %2, R3                  ;; if(i<m) R3=1
    
    ;; addr for next loop_m
    SADD.M1     R57, R42, R42           ;; R42 += (N+2)*4*8
    SADD.M1     R57, R43, R43           ;; R43 += (N+2)*4*8
    SADD.M1     R57, R44, R44           ;; R44 += (N+2)*4*8
    SADD.M1     R57, R45, R45           ;; R45 += (N+2)*4*8

    SMOVI24     0, R8                   ;; j=0
    loop_n:
        SADD    R59, R8, R8             ;; j += 64
        SLT     R8, %3, R0              ;; if(j<n) R0=1
        
        ;; ---------------------------------------------------------------
        ;; 写回上一轮的数据 ...

        ;; if(j_pre < n)
        [R1] SADDA.M1   		R61, AR5, AR5       ;; AR5 += 16*4*8
        [R1] SADDA.M1   		R61, AR6, AR6       ;; AR5 += 16*4*8
        ;; else
        [!R1] SMVAGA.M1         %1, AR5             ;; AR5_next = %1
        [!R1] SMVAGA.M1         R46, AR6            ;; AR6_next = R46
        ;; ---------------------------------------------------------------

        ;; 计算本轮的数据 ...

        ;; ---------------------------------------------------------------
        ;; if(j_cur < n)
        [R0] SADDA.M1           R61, AR0, AR0       ;; AR0 += 16*4*8
        [R0] SADDA.M1           R61, AR1, AR1       ;; AR1 += 16*4*8
        [R0] SADDA.M1           R61, AR2, AR2       ;; AR2 += 16*4*8
        [R0] SADDA.M1           R61, AR3, AR3       ;; AR3 += 16*4*8
        ;; else
        [!R0] SMVAGA.M1         R42, AR0            ;; AR0_next = R42
        [!R0] SMVAGA.M1         R43, AR1            ;; AR1_next = R43
        [!R0] SMVAGA.M1         R44, AR2            ;; AR2_next = R44
        [!R0] SMVAGA.M1         R45, AR3            ;; AR3_next = R45

        ;; 加载下一轮的数据 ...
        ;; ---------------------------------------------------------------
        
        SMOVI   R0, R1                              ;; R1 = R0
    [R0] SBR    loop_n 

    ;; addr for next loop_m
    SADD.M1     R52, %1, %1             ;; %1 += N*4*8
    SADD.M1     R52, R46, R46           ;; R46 += N*4*8
    
[R3] SBR   loop_m

;; 写回最后一轮的数据 ...
=================================================================





计算顺序：
=================================================================
外层循环(loop_m)遍历行, 步长为4,
内层循环(loop_n)遍历列, 步长为64,
一次处理4x64的数据块.
---------------------------------------------------------------
用到的向量寄存器及各自的相对位置如下:
A:
                VR(0~3)     
    VR(4~7)     VR(8~1)     VR(12~15)
    VR(16~19)   VR(20~23)   VR(24~27)
    VR(28~31)   VR(32~35)   VR(36~39)
    VR(40~43)   VR(44~47)   VR(48~51)
                VR(52~55)
B:
    VR(12~15)
    VR(24~27)
    VR(36~39)
    VR(48~51)

对应的首地址分别是：
A:
                AR0++[OR1]
    AR1++[OR1]  AR0--[OR1]  AR2++[OR1]
    AR1++[OR1]  AR3++[OR1]  AR2++[OR1]
    AR1++[OR1]  AR3++[OR1]  AR2++[OR1]
    AR1--[OR3]  AR3++[OR1]  AR2--[OR3]
                AR3--[OR3]
B:
    AR5++[OR5]     
    AR5--[OR5]
    AR6++[OR5]
    AR6--[OR5]
-----------------------------------------------------------------
向量运算的过程是：     
[1] VR(4~7) += VR(0~3) | [2] VR(8~11) += VR(20~23)
[3] VR(4~7) += VR(8~11)
[4] VR(12~15) += VR(4~7)

[5] VR(16~19) += VR(32~35)
[6] VR(16~19) += VR(8~11)
[7] VR(24~27) += VR(16~19)

[8] VR(28~31) += VR(20~23) | [9] VR(32~35) += VR(44~47)
[10] VR(28~31) += VR(32~35)
[11] VR(36~39) += VR(28~31)

[12] VR(40~44) += VR(52~55)
[13] VR(40~44) += VR(32~35)
[14] VR(48~51) += VR(40~44)

[15] VR(12~15) *= 0.2
[16] VR(24~27) *= 0.2
[17] VR(36~39) *= 0.2
[18] VR(48~51) *= 0.2

在代码中的顺序是：
[1] -> [2] -> [5] -> [8] -> [9] ->[12] ->
[3] -> [6] -> [10] -> [13] ->
[4] -> [7] -> [11] -> [14] ->
[15] -> [16] -> [17] ->[18]
=================================================================